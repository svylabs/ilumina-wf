{
  "execution": {
    "action_name": "borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safe.borrowedAmount",
            "type": "uint256",
            "summary_of_update": "Increase `borrowedAmount` of the `safe` by `debtIncrease`. This represents the increase in debt for the safe due to accrued interest or other factors.",
            "has_conditional_updates": true,
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safe.totalBorrowedAmount",
            "type": "uint256",
            "summary_of_update": "Increase `totalBorrowedAmount` of the `safe` by `debtIncrease`. This represents the total amount ever borrowed by the safe, incremented by the current debt increase.",
            "has_conditional_updates": true,
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshot.debtPerCollateralSnapshot",
            "type": "uint256",
            "summary_of_update": "Update the `debtPerCollateralSnapshot` in `liquidationSnapshot` to `cumulativeDebtPerUnitCollateral`. This snapshot is used to track debt accrual relative to collateral.",
            "has_conditional_updates": true,
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "safe.collateralAmount",
            "type": "uint256",
            "summary_of_update": "Increase `collateralAmount` of the `safe` by `collateralIncrease`. This reflects adjustments to the collateral amount due to system-wide updates.",
            "has_conditional_updates": true,
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshot.collateralPerCollateralSnapshot",
            "type": "uint256",
            "summary_of_update": "Update the `collateralPerCollateralSnapshot` in `liquidationSnapshot` to `cumulativeCollateralPerUnitCollateral`. This snapshot is used for tracking collateral adjustments.",
            "has_conditional_updates": true,
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "summary_of_update": "Increase `totalCollateral` by `collateralIncrease`. This reflects the overall increase in collateral within the system.",
            "has_conditional_updates": true,
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "summary_of_update": "Potentially change `PROTOCOL_MODE` to `NORMAL` if `totalDebt` exceeds `BOOTSTRAP_MODE_DEBT_THRESHOLD` and the protocol is currently in `BOOTSTRAP` mode.  This represents a transition from an initial bootstrapping phase to normal operation.",
            "has_conditional_updates": true,
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD",
              "PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "summary_of_update": "Increase `totalDebt` by `amount` if amount is greater than zero.",
            "has_conditional_updates": true,
            "conditions": [
              "amount > 0"
            ]
          },
          {
            "state_variable_name": "safe.weight",
            "type": "uint256",
            "summary_of_update": "Set `safe.weight` to `shieldingRate` if it's the first time borrowing for the safe and there are no existing borrowings in the system. `weight` affects fee calculation.",
            "has_conditional_updates": true,
            "conditions": [
              "safe.borrowedAmount == 0",
              "_minFeeWeightNode == 0"
            ]
          },
          {
            "state_variable_name": "safe.weight",
            "type": "uint256",
            "summary_of_update": "Adjust `safe.weight` based on the minimum fee weight if it's the first time borrowing and there are existing borrowings. This ensures fairness for new borrowers.",
            "has_conditional_updates": true,
            "conditions": [
              "safe.borrowedAmount == 0",
              "_minFeeWeightNode != 0"
            ]
          },
          {
            "state_variable_name": "safe.weight",
            "type": "uint256",
            "summary_of_update": "Update `safe.weight` with a new weighted fee if `shieldingRate` is greater than 0. This dynamically adjusts the fee based on borrowing activity.",
            "has_conditional_updates": true,
            "conditions": [
              "safe.borrowedAmount != 0",
              "shieldingRate > 0"
            ]
          },
          {
            "state_variable_name": "safe.borrowedAmount",
            "type": "uint256",
            "summary_of_update": "Increase `borrowedAmount` of the `safe` by `amount`. This is the core update reflecting the borrowed amount.",
            "has_conditional_updates": false,
            "conditions": []
          },
          {
            "state_variable_name": "safe.totalBorrowedAmount",
            "type": "uint256",
            "summary_of_update": "Increase `totalBorrowedAmount` of the `safe` by `amount`. This tracks the total amount ever borrowed.",
            "has_conditional_updates": false,
            "conditions": []
          },
          {
            "state_variable_name": "safe.feePaid",
            "type": "uint256",
            "summary_of_update": "Increase `feePaid` of the `safe` by `_shieldingFee`. This accumulates the fees paid by the safe.",
            "has_conditional_updates": false,
            "conditions": []
          }
        ]
      }
    ]
  },
  "detail": {
    "action_name": "borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "pre_execution_parameter_generation_rules": [
      "The `amount` parameter should be a positive integer representing the amount to borrow.",
      "The `safe` parameter must reference a valid Safe that exists in the system before the function call.",
      "Determine a `shieldingRate`. If system is in BOOTSTRAP mode, use a high shielding rate, else determine based on system health."
    ],
    "on_execution_state_updates_made": [
      {
        "category": "Debt Update",
        "state_update_descriptions": [
          "Increase `safe.borrowedAmount` by `amount`.",
          "Increase `safe.totalBorrowedAmount` by `amount`.",
          "Increase `totalDebt` by `amount` (if amount > 0)."
        ]
      },
      {
        "category": "Collateral Snapshot Update",
        "state_update_descriptions": [
          "These updates only happen during system-wide updates.",
          "If `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`:",
          "Update `liquidationSnapshot.debtPerCollateralSnapshot` to `cumulativeDebtPerUnitCollateral`.",
          "Increase `safe.collateralAmount` by `collateralIncrease`.",
          "Update `liquidationSnapshot.collateralPerCollateralSnapshot` to `cumulativeCollateralPerUnitCollateral`.",
          "Increase `totalCollateral` by `collateralIncrease`."
        ]
      },
      {
        "category": "Fee and Weight Update",
        "state_update_descriptions": [
          "Increase `safe.feePaid` by `_shieldingFee`.",
          "If `safe.borrowedAmount == 0` and `_minFeeWeightNode == 0`, set `safe.weight` to `shieldingRate`.",
          "If `safe.borrowedAmount == 0` and `_minFeeWeightNode != 0`, adjust `safe.weight` based on the minimum fee weight.",
          "If `safe.borrowedAmount != 0` and `shieldingRate > 0`, update `safe.weight` with a new weighted fee."
        ]
      },
      {
        "category": "Protocol Mode Update",
        "state_update_descriptions": [
          "Potentially change `PROTOCOL_MODE` to `NORMAL` if `totalDebt` exceeds `BOOTSTRAP_MODE_DEBT_THRESHOLD` and the protocol is currently in `BOOTSTRAP` mode."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "category": "Debt Update",
        "rule_descriptions": [
          "`safe.borrowedAmount` should be greater than or equal to its previous value.",
          "`safe.totalBorrowedAmount` should be greater than or equal to its previous value.",
          "`totalDebt` should be greater than or equal to its previous value (if amount > 0)."
        ]
      },
      {
        "category": "Collateral Snapshot Update",
        "rule_descriptions": [
          "If collateral snapshot was updated, ensure that `liquidationSnapshot.debtPerCollateralSnapshot` reflects the current `cumulativeDebtPerUnitCollateral`.",
          "`safe.collateralAmount` should be greater than or equal to its previous value if updated.",
          "`totalCollateral` should be greater than or equal to its previous value if updated.",
          "`liquidationSnapshot.collateralPerCollateralSnapshot` should reflect current `cumulativeCollateralPerUnitCollateral` if updated."
        ]
      },
      {
        "category": "Fee and Weight Update",
        "rule_descriptions": [
          "`safe.feePaid` should be greater than or equal to its previous value.",
          "`safe.weight` should be a positive number. If `shieldingRate` is non-zero, `safe.weight` should reflect the `shieldingRate` based on the system parameters.",
          "If `shieldingRate` is 0, `safe.weight` should remain unchanged."
        ]
      },
      {
        "category": "Protocol Mode Update",
        "rule_descriptions": [
          "If `PROTOCOL_MODE` changed to `NORMAL`, ensure `totalDebt` exceeds `BOOTSTRAP_MODE_DEBT_THRESHOLD`.",
          "If `totalDebt` does not exceed `BOOTSTRAP_MODE_DEBT_THRESHOLD` and the protocol is not in `BOOTSTRAP` mode, `PROTOCOL_MODE` should not change."
        ]
      }
    ]
  }
}