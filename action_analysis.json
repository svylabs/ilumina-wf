{
  "execution": {
    "action_name": "borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "does_register_new_identifier": false,
    "new_identifiers": [],
    "all_state_updates": [
      {
        "contract_name": "StableBaseCDP",
        "state_updated": [
          {
            "state_variable_name": "safes[safeId].borrowedAmount",
            "type": "uint256",
            "summary_of_update": "Updates the borrowedAmount, totalBorrowedAmount, and feePaid of the safe",
            "has_conditional_updates": false,
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].totalBorrowedAmount",
            "type": "uint256",
            "summary_of_update": "Updates the borrowedAmount, totalBorrowedAmount, and feePaid of the safe",
            "has_conditional_updates": false,
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].feePaid",
            "type": "uint256",
            "summary_of_update": "Updates the borrowedAmount, totalBorrowedAmount, and feePaid of the safe",
            "has_conditional_updates": false,
            "conditions": []
          },
          {
            "state_variable_name": "safes[safeId].weight",
            "type": "uint256",
            "summary_of_update": "Updates the weight of the safe. If it is the first time borrowing, the weight is set based on either the shieldingRate or the minimum fee weight. Otherwise, the weight is adjusted based on the existing weight and the shieldingRate.",
            "has_conditional_updates": true,
            "conditions": [
              "safe.borrowedAmount == 0 && _minFeeWeightNode == 0",
              "safe.borrowedAmount == 0 && _minFeeWeightNode != 0",
              "safe.borrowedAmount != 0 && shieldingRate > 0"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[_safeId].debtPerCollateralSnapshot",
            "type": "uint256",
            "summary_of_update": "Updates the cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral",
            "has_conditional_updates": true,
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "liquidationSnapshots[_safeId].collateralPerCollateralSnapshot",
            "type": "uint256",
            "summary_of_update": "Updates the cumulativeDebtPerUnitCollateral and cumulativeCollateralPerUnitCollateral",
            "has_conditional_updates": true,
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalCollateral",
            "type": "uint256",
            "summary_of_update": "Increases totalCollateral",
            "has_conditional_updates": true,
            "conditions": [
              "liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral"
            ]
          },
          {
            "state_variable_name": "totalDebt",
            "type": "uint256",
            "summary_of_update": "Updates the total debt",
            "has_conditional_updates": false,
            "conditions": []
          },
          {
            "state_variable_name": "PROTOCOL_MODE",
            "type": "enum",
            "summary_of_update": "Updates the protocol mode from BOOTSTRAP to NORMAL if the total debt exceeds a threshold.",
            "has_conditional_updates": true,
            "conditions": [
              "debt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP"
            ]
          }
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updated": [
          {
            "state_variable_name": "nodes[safeId]",
            "type": "IDoublyLinkedList.Node",
            "summary_of_update": "Upserts the safeId to the redemption list",
            "has_conditional_updates": false,
            "conditions": []
          },
          {
            "state_variable_name": "nodes[safeId]",
            "type": "IDoublyLinkedList.Node",
            "summary_of_update": "Upserts the safeId to the liquidation list",
            "has_conditional_updates": false,
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updated": [
          {
            "state_variable_name": "_balances[msg.sender]",
            "type": "uint256",
            "summary_of_update": "Mints SBD tokens to the borrower",
            "has_conditional_updates": false,
            "conditions": []
          }
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "summary_of_update": "Adds reward to the dfireTokenStaking contract",
            "has_conditional_updates": true,
            "conditions": [
              "feeAdded1"
            ]
          }
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updated": [
          {
            "state_variable_name": "totalRewardPerToken",
            "type": "uint256",
            "summary_of_update": "Adds reward to the stability pool",
            "has_conditional_updates": true,
            "conditions": [
              "feeAdded2"
            ]
          }
        ]
      }
    ]
  },
  "detail": {
    "action_name": "borrow",
    "contract_name": "StableBaseCDP",
    "function_name": "borrow",
    "pre_execution_parameter_generation_rules": [
      "Generate `safeId`: This must be an existing safe ID owned by the caller.",
      "Generate `amount`: This represents the amount of SBD tokens to borrow; must be a non-negative integer.",
      "Ensure the generated `amount` adheres to system-wide debt limits and the safe's collateralization ratio. The borrowed amount plus existing debt, including fees, should not exceed the maximum allowable debt for the safe, considering the collateral deposited.",
      "If `_minFeeWeightNode` is zero, ensure the `shieldingRate` is not less than the global `MIN_SHIELDING_RATE`."
    ],
    "on_execution_state_updates_made": [
      {
        "contract_name": "StableBaseCDP",
        "state_updates": [
          "Updates `safes[safeId].borrowedAmount` by adding the borrowed amount: `safes[safeId].borrowedAmount += amount`.",
          "Updates `safes[safeId].totalBorrowedAmount` by adding the borrowed amount: `safes[safeId].totalBorrowedAmount += amount`.",
          "Updates `safes[safeId].feePaid` to account for borrow fees. Fee calculation depends on system parameters and the borrowed amount.",
          "If `safe.borrowedAmount == 0` and `_minFeeWeightNode == 0`, `weight` is set based on `shieldingRate`: `safe.weight = shieldingRate`. If `safe.borrowedAmount == 0` and `_minFeeWeightNode != 0`, `safe.weight` is set to `MIN_FEE_WEIGHT`.",
          "If `safe.borrowedAmount != 0` and `shieldingRate > 0`, `weight` is updated based on `shieldingRate` and existing `weight`: `safe.weight = (safe.weight * (100 - shieldingRate) + shieldingRate * MAX_WEIGHT) / 100`.",
          "Updates `liquidationSnapshots[_safeId].debtPerCollateralSnapshot` to `cumulativeDebtPerUnitCollateral` if `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
          "Updates `liquidationSnapshots[_safeId].collateralPerCollateralSnapshot` to `cumulativeCollateralPerUnitCollateral` if `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
          "Increases `totalCollateral` if `liquidationSnapshot.collateralPerCollateralSnapshot != cumulativeCollateralPerUnitCollateral`.",
          "Updates `totalDebt`: `totalDebt += amount + fee`.",
          "Updates `PROTOCOL_MODE` from `BOOTSTRAP` to `NORMAL` if `totalDebt > BOOTSTRAP_MODE_DEBT_THRESHOLD && PROTOCOL_MODE == SBStructs.Mode.BOOTSTRAP`."
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "state_updates": [
          "Upserts `safeId` into the redemption list, ordered by `weight`.",
          "Upserts `safeId` into the liquidation list, ordered by `weight`."
        ]
      },
      {
        "contract_name": "DFIDToken",
        "state_updates": [
          "Mints `amount` of SBD tokens to `msg.sender`: `_balances[msg.sender] += amount`."
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "state_updates": [
          "Increases `totalRewardPerToken` based on a fraction of the borrow fee, if applicable: `totalRewardPerToken += fee * some_fraction` if `feeAdded1`."
        ]
      },
      {
        "contract_name": "StabilityPool",
        "state_updates": [
          "Increases `totalRewardPerToken` based on a fraction of the borrow fee, if applicable: `totalRewardPerToken += fee * some_fraction` if `feeAdded2`."
        ]
      }
    ],
    "post_execution_contract_state_validation_rules": [
      {
        "contract_name": "StableBaseCDP",
        "rules": [
          "Verify `safes[safeId].borrowedAmount` is equal to the initial value plus `amount`.",
          "Verify `safes[safeId].totalBorrowedAmount` is equal to the initial value plus `amount`.",
          "Verify `safes[safeId].feePaid` is calculated correctly using the borrow fee formula.",
          "If first time borrowing, verify `safe.weight` equals `shieldingRate` when `_minFeeWeightNode` is zero, or equals `MIN_FEE_WEIGHT` when `_minFeeWeightNode` is non-zero.",
          "If not first time borrowing and `shieldingRate > 0`, verify the `weight` is updated correctly using the formula `safe.weight = (safe.weight * (100 - shieldingRate) + shieldingRate * MAX_WEIGHT) / 100`.",
          "Verify `debtPerCollateralSnapshot` and `collateralPerCollateralSnapshot` in `liquidationSnapshots[_safeId]` are updated to the cumulative values if the initial values were different.",
          "Verify `totalDebt` increased by the borrowed `amount` plus the borrow `fee`.",
          "If applicable verify that the `PROTOCOL_MODE` is `NORMAL` when the total debt is greater than `BOOTSTRAP_MODE_DEBT_THRESHOLD`."
        ]
      },
      {
        "contract_name": "OrderedDoublyLinkedList",
        "rules": [
          "Verify `safeId` exists in both redemption and liquidation lists, positioned according to its `weight`."
        ]
      },
      {
        "contract_name": "DFIDToken",
        "rules": [
          "Verify `_balances[msg.sender]` increased by `amount`."
        ]
      },
      {
        "contract_name": "DFIREStaking",
        "rules": [
          "If `feeAdded1`, verify that `totalRewardPerToken` increased by the correct reward amount based on the borrow fee."
        ]
      },
      {
        "contract_name": "StabilityPool",
        "rules": [
          "If `feeAdded2`, verify that `totalRewardPerToken` increased by the correct reward amount based on the borrow fee."
        ]
      }
    ]
  }
}