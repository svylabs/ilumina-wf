import os
import json
from .models import SnapshotDataStructure, DeploymentInstruction
from .context import RunContext, prepare_context_lazy
from .three_stage_llm_call import ThreeStageAnalyzer
from typing import Dict, List

class SnapshotCodeGenerator:
    def __init__(self, context: RunContext):
        self.context = context
        self.analyzer = ThreeStageAnalyzer(SnapshotDataStructure)

    def generate(self):
        """
        Generate the snapshot data structure for all contracts in the project.
        """
        #contracts = self.context.deployed_contracts()
        print(f"📁 Deployment instructions path: {self.context.deployment_instructions_path()}")
        deployment_instructions = self.context.deployment_instructions()
        if deployment_instructions is None:
            print("Error: deployment_instructions is None. Please check your context or deployment instructions source.")
            return
        interfaces = ""
        snapshot_functions = []
        
        # Track contract references to handle multiple deployments of same contract
        contract_references: Dict[str, List[str]] = {}
        
        for item in deployment_instructions.sequence:
            if item.type == "deploy":
                contract_name = item.contract
                ref_name = item.ref_name
                
                # Track contract references
                if contract_name not in contract_references:
                    contract_references[contract_name] = []
                contract_references[contract_name].append(ref_name)
                
                print(f"Generating snapshot data structure for {contract_name} ({ref_name})...")
                snapshot_path = self.context.snapshot_data_structure_path(contract_name)
                #print (snapshot_path)
                snapshot_data_structure = SnapshotDataStructure.load_summary(snapshot_path)
                
                if snapshot_data_structure is None:
                    print(f"Snapshot data structure for {contract_name} not found. Skipping...")
                    continue

                interfaces += self._exported(snapshot_data_structure.typescript_interfaces.common_contract_state_snapshot_interface_code)
                interfaces += self._exported(snapshot_data_structure.typescript_interfaces.user_data_snapshot_interface_code)
                
                # Generate snapshot functions for this contract
                snapshot_code = self._generate_snapshot_functions(
                    contract_name, 
                    ref_name,
                    snapshot_data_structure
                )
                if isinstance(snapshot_code, str):
                    snapshot_functions.append(snapshot_code)
                else:
                    print(f"Warning: Expected string from _generate_snapshot_functions for {contract_name} ({ref_name}), got {type(snapshot_code)}. Skipping.")
        
        # Write interfaces file
        with open(self.context.snapshot_interface_code_path(), 'w') as f:
            f.write("// Generated by SnapshotCodeGenerator\n\n")
            f.write(interfaces)
            print(interfaces)
        
        # Write snapshot functions file
        snapshot_code_path = os.path.join(
            os.path.dirname(self.context.snapshot_interface_code_path()),
            "snapshot_functions.ts"
        )
        with open(snapshot_code_path, 'w') as f:
            f.write("// Generated by SnapshotCodeGenerator\n\n")
            f.write("import { ethers } from 'ethers';\n")
            f.write("import BigNumber from 'bignumber.js';\n\n")
            f.write("\n\n".join(snapshot_functions))
            f.write("\n\n")
            f.write(self._generate_snapshot_provider(contract_references))
        
        self.context.commit("Snapshot interfaces and functions generated successfully.")

    def _generate_snapshot_functions(self, contract_name: str, ref_name: str, snapshot_data: SnapshotDataStructure) -> str:
        """
        Generate TypeScript functions to take contract and user snapshots
        """
        prompt = f"""
        Generate complete, production-ready TypeScript functions to snapshot the state of {contract_name} contract (reference: {ref_name}).
        
        Requirements:
        1. Generate two functions:
           - take{ref_name}ContractSnapshot: For contract state
           - take{ref_name}UserSnapshot: For user-specific data
        2. Must handle BigNumber conversions properly
        3. Include comprehensive error handling
        4. Use async/await properly
        5. Follow the snapshot data structure:
           {json.dumps(snapshot_data.to_dict(), indent=2)}
        6. Each function should accept:
           - contract: ethers.Contract instance
           - (for user snapshot) userIds: string[]
        7. Return type should match the interfaces from the snapshot data structure
        8. Include detailed JSDoc comments
        9. Import any required dependencies
        
        Output format:
        ```
        /**
         * Takes a snapshot of {contract_name} contract state
         * @param contract - ethers.Contract instance
         * @returns Promise with contract state snapshot
         */
        export async function take{ref_name}ContractSnapshot(contract: ethers.Contract): Promise<...> {{
            // Implementation
        }}
        
        /**
         * Takes a snapshot of {contract_name} user data
         * @param contract - ethers.Contract instance
         * @param userIds - Array of user addresses
         * @returns Promise with user data snapshots
         */
        export async function take{ref_name}UserSnapshot(
            contract: ethers.Contract,
            userIds: string[]
        ): Promise<...> {{
            // Implementation
        }}
        ```
        """
        
        response = self.analyzer.ask_llm(prompt)
        return response.code if hasattr(response, 'code') else response

    def _generate_snapshot_provider(self, contract_references: Dict[str, List[str]]) -> str:
        """
        Generate a provider class that aggregates all snapshot functions
        """
        provider_code = """
interface SnapshotResult {
    timestamp: string;
    data: Record<string, any>;
}

interface UserSnapshotResult {
    userIds: string[];
    timestamp: string;
    data: Record<string, any>;
}

/**
 * Provider class for taking complete project snapshots
 */
export class SnapshotProvider {
    private contracts: Record<string, ethers.Contract>;
    
    constructor(contracts: Record<string, ethers.Contract>) {
        this.contracts = contracts;
    }
    
    /**
     * Takes a complete snapshot of all contract states
     */
    async takeFullSnapshot(): Promise<SnapshotResult> {
        const results: Record<string, any> = {};
        const timestamp = new Date().toISOString();
        """
        
        # Add contract snapshot calls
        for contract_name, refs in contract_references.items():
            for ref in refs:
                provider_code += f"""
        if (this.contracts['{ref}']) {{
            try {{
                results['{ref}'] = await take{ref}ContractSnapshot(this.contracts['{ref}']);
            }} catch (error) {{
                results['{ref}'] = {{ 
                    error: error instanceof Error ? error.message : String(error),
                    stack: error instanceof Error ? error.stack : undefined
                }};
            }}
        }}
                """
        
        provider_code += """
        return {
            timestamp,
            data: results
        };
    }
    
    /**
     * Takes a complete snapshot of all user data
     * @param userIds Array of user addresses
     */
    async takeUserSnapshot(userIds: string[]): Promise<UserSnapshotResult> {
        if (!userIds || userIds.length === 0) {
            throw new Error("Must provide at least one user ID");
        }
        
        const results: Record<string, any> = {};
        const timestamp = new Date().toISOString();
        """
        
        # Add user snapshot calls
        for contract_name, refs in contract_references.items():
            for ref in refs:
                provider_code += f"""
        if (this.contracts['{ref}']) {{
            try {{
                results['{ref}'] = await take{ref}UserSnapshot(this.contracts['{ref}'], userIds);
            }} catch (error) {{
                results['{ref}'] = {{ 
                    error: error instanceof Error ? error.message : String(error),
                    stack: error instanceof Error ? error.stack : undefined
                }};
            }}
        }}
                """
        
        provider_code += """
        return {
            userIds,
            timestamp,
            data: results
        };
    }
}
"""
        return provider_code

    def _exported(self, code: str) -> str:
        """
        Helper function to format exported code
        """
        if code.startswith("export "):
            return code + "\n\n"
        if code.startswith("interface "):
            return code.replace("interface ", "export interface ") + "\n\n"
        return code

if __name__ == "__main__":
    context = prepare_context_lazy({
        # "run_id": "1747743579",
        # "submission_id": "b2467fc4-e77a-4529-bcea-09c31cb2e8fe",
        # "github_repository_url": "https://github.com/svylabs/stablebase"
        "run_id": "3",
        "submission_id": "s3",
        "github_repository_url": "https://github.com/svylabs-com/sample-hardhat-project"
    })
    generator = SnapshotCodeGenerator(context)
    generator.generate()
    print("Snapshot code generation completed.")