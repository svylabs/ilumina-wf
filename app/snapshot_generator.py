# snapshot_generator.py
import json
import re
from .three_stage_llm_call import ThreeStageAnalyzer
from .models import SnapshotCode, Project
import os

class SnapshotGenerator:
    def __init__(self, context):
        self.context = context
        self.analyzer = ThreeStageAnalyzer(SnapshotCode)

    def generate_for_contract(self, contract_name: str):
        artifact_path = self.context.contract_artifact_path(contract_name)
        with open(artifact_path, 'r') as f:
            artifact = json.load(f)
        
        abi = artifact['abi']
        
        prompt = f"""
        Generate complete TypeScript code for a {contract_name}Snapshot class that implements snapshot functionality.
        
        Contract ABI:
        {json.dumps(abi)}
        
        Requirements:
        1. Must include ALL necessary imports at the top
        2. Class must be named {contract_name}Snapshot
        3. Must implement method: async snapshot(contract: ethers.Contract, identifiers?: Record<string, string>): Promise<any>
        4. Properly handle BigNumber values by converting to strings
        5. Handle both cases: with and without identifiers
        6. Comprehensive error handling that preserves error stack traces
        7. Type all method parameters and return values properly
        8. Include JSDoc comments for all methods
        9. Generate complete, ready-to-use code
        10. Must work with ethers.js v5+
        
        Output Format:
        ```typescript
        // All necessary imports here
        import ... from ...;
        
        /**
         * JSDoc comment describing the snapshot class
         */
        class {contract_name}Snapshot {{
            /**
             * Takes snapshot of contract state
             * @param contract - The ethers Contract instance
             * @param identifiers - Optional identifiers for filtered snapshot
             * @returns Promise with snapshot data or error information
             */
            async snapshot(contract: ethers.Contract, identifiers?: Record<string, string>): Promise<any> {{
                // Implementation here
            }}
        }}
        ```
        """
        
        snapshot_code = self.analyzer.ask_llm(prompt)
        return snapshot_code

    def generate_all_snapshots(self):
        project = Project.load_summary(self.context.summary_path())
        snapshots = {}
        
        for contract in project.contracts:
            if contract.is_deployable:
                snapshot = self.generate_for_contract(contract.name)
                snapshots[contract.name] = snapshot
        
        return snapshots

    def save_snapshots(self, output_path: str):
        snapshots = self.generate_all_snapshots()
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        
        with open(output_path, 'w') as f:
            # Let the LLM handle all imports in the main provider
            f.write("""import { SnapshotProvider } from "@svylabs/ilumina";

""")
            
            # Write individual snapshot classes exactly as generated by LLM
            for contract_name, snapshot in snapshots.items():
                f.write(f"// Snapshot for {contract_name}\n")
                f.write(snapshot.code + "\n\n")
            
            # Generate dynamic main provider
            implementations = "\n        ".join(
                f"this.snapshotImplementations['{name}'] = new {name}Snapshot();"
                for name in snapshots.keys()
            )
            
            f.write(f"""
interface SnapshotResult {{
    identifiers?: Record<string, string>;
    timestamp: string;
    data: Record<string, any>;
}}

export class ContractSnapshotProvider implements SnapshotProvider {{
    private contracts: Record<string, ethers.Contract>;
    private snapshots: Record<string, any> = {{}};
    private snapshotImplementations: Record<string, any> = {{}};

    constructor(contracts: Record<string, ethers.Contract>) {{
        this.contracts = contracts;
        // Initialize snapshot implementations
        {implementations}
    }}

    /**
     * Takes snapshot of all contracts
     * @param identifiers - Optional record of identifiers for filtered snapshots
     * @returns Promise with complete snapshot results
     */
    async snapshot(identifiers?: Record<string, string>): Promise<SnapshotResult> {{
        const results: Record<string, any> = {{}};
        
        for (const [name, contract] of Object.entries(this.contracts)) {{
            if (this.snapshotImplementations[name]) {{
                try {{
                    results[name] = await this.snapshotImplementations[name].snapshot(contract, identifiers);
                }} catch (error) {{
                    results[name] = {{
                        error: {{
                            message: (error instanceof Error) ? error.message : 'Unknown error',
                            stack: (error instanceof Error) ? error.stack : undefined
                        }}
                    }};
                }}
            }}
        }}
        
        return {{
            identifiers: identifiers || {{}},
            timestamp: new Date().toISOString(),
            data: results
        }};
    }}

    getSnapshots(): Record<string, any> {{
        return this.snapshots;
    }}
}}
""")